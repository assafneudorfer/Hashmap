# HashMap and Spam Detector

A C++ implementation of a custom hash table data structure with dynamic resizing and a practical spam detection application.

## Project Overview

This project consists of two main components:

1. **HashMap** - A templated hash table implementation with:
   - Bucket-based collision handling using chaining
   - Dynamic resizing based on configurable load factors
   - Custom const_iterator for traversal
   - Standard operations: insert, erase, lookup, and more

2. **SpamDetector** - A practical application that uses the HashMap to detect spam messages by scoring keyword occurrences against a threshold.

## Features

### HashMap Implementation
- Generic templated design works with any key-value types
- Automatic resizing when load factor exceeds thresholds (default: 0.25-0.75)
- Efficient hash-based lookups with O(1) average case
- Support for copy/move semantics
- STL-style const_iterator interface

### Spam Detection
- Keyword-based scoring system
- Case-insensitive matching
- Configurable threshold for spam classification
- Simple CSV-style database format

## Building the Project

```bash
mkdir build
cd build
cmake ..
make
```

## Usage

### Spam Detector
```bash
./SpamDetector <database_path> <email_path> <threshold>
```

Example:
```bash
./SpamDetector test/1database.txt test/1mail.txt 100
```

The database file format is:
```
keyword1,score1
keyword2,score2
```

The program analyzes the email file, calculates a spam score based on keyword matches, and outputs either `SPAM` or `NOT_SPAM`.

## Project Structure

- `HashMap.hpp` - Core hash table implementation
- `SpamDetector.cpp` - Spam detection application
- `test/` - Sample database and email files for testing
- `CMakeLists.txt` - Build configuration

## Implementation Details

The HashMap uses:
- Power-of-2 table sizes for efficient bitwise hashing
- std::vector for bucket storage
- Separate chaining for collision resolution
- Rehashing when load factor boundaries are crossed
